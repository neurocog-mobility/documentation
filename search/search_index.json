{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neuro-cognition &amp; Moblility Lab Documentation","text":"<p>TODO: Add README.md</p>"},{"location":"nimbal/","title":"NiMBaL Toolkit","text":"<p>nimbalwear is an open source toolkit for processing data from wearable sensors. For toolkit source visit nimbalwear.</p>"},{"location":"nimbal/#installation","title":"Installation","text":"<p>To install the latest release of nimbalwear directly from GitHub using pip, run the following line in terminal or console:</p> <p><code>pip install git+https://github.com/nimbal/nimbalwear</code></p> <p>To install a specific release, insert M.m after the repository name to install from the branch associated with that minor release. For example:</p> <p><code>pip install git+https://github.com/nimbal/nimbalwear@0.21</code></p>"},{"location":"nimbal/#package-dependency","title":"Package Dependency","text":"<p>To include the latest release of nimbalwear as a dependency in your Python package, include the following line in <code>setup.py</code> or include the string within the list alongside your other dependencies:</p> <pre><code>install_requires=['nimbalwear@git+https://github.com/nimbal/nimbalwear@[version]']\n</code></pre> <p>To include a specific release, replace <code>[version]</code> with the branch associated with that minor release.</p>"},{"location":"nimbal/usage/class_device/","title":"The 'Device' class","text":"<p>The <code>Device</code> class is used to store raw device data.</p>"},{"location":"nimbal/usage/class_device/#class-directory","title":"Class directory","text":""},{"location":"nimbal/usage/class_device/#properties","title":"Properties","text":""},{"location":"nimbal/usage/class_device/#header","title":"header","text":"<p>Device collection metadata:</p> <p>study_code subject_id, coll_id, name, sex, birthdate, patient_additional, start_datetime, config_datetime, technician, device_type, device_id, device_location, recording_additional</p>"},{"location":"nimbal/usage/class_device/#signal_headers","title":"signal_headers","text":"<p>List of dictionaries holding metadata for each device channel:</p> <p>label, transducer, dimension, sample_rate, physical_max, physical_min, digital_max, digital_min, prefilter</p>"},{"location":"nimbal/usage/class_device/#signals","title":"signals","text":"<p>List of raw data signals for each device channel.</p>"},{"location":"nimbal/usage/class_device/#methods","title":"Methods","text":""},{"location":"nimbal/usage/class_device/#autocal","title":"autocal()","text":""},{"location":"nimbal/usage/class_device/#crop","title":"crop()","text":""},{"location":"nimbal/usage/class_device/#deidentify","title":"deidentify()","text":""},{"location":"nimbal/usage/class_device/#export_edf","title":"export_edf()","text":""},{"location":"nimbal/usage/class_device/#get_day_idxs","title":"get_day_idxs()","text":""},{"location":"nimbal/usage/class_device/#get_idxs_from_date","title":"get_idxs_from_date()","text":""},{"location":"nimbal/usage/class_device/#get_signal_index","title":"get_signal_index()","text":""},{"location":"nimbal/usage/class_device/#get_timestamps","title":"get_timestamps()","text":""},{"location":"nimbal/usage/class_device/#import_axivity","title":"import_axivity()","text":""},{"location":"nimbal/usage/class_device/#import_bittium","title":"import_bittium()","text":""},{"location":"nimbal/usage/class_device/#import_edf","title":"import_edf()","text":""},{"location":"nimbal/usage/class_device/#import_geneactiv","title":"import_geneactiv()","text":""},{"location":"nimbal/usage/class_device/#rotate_z","title":"rotate_z()","text":""},{"location":"nimbal/usage/class_device/#sync","title":"sync()","text":""},{"location":"nimbal/usage/class_pipeline/","title":"The 'Pipeline' class","text":""},{"location":"nimbal/usage/modules/","title":"Modules","text":""},{"location":"nimbal/usage/modules/#activity","title":"activity","text":""},{"location":"nimbal/usage/modules/#data","title":"data","text":""},{"location":"nimbal/usage/modules/#gait","title":"gait","text":""},{"location":"nimbal/usage/modules/#gait_accel","title":"gait_accel","text":""},{"location":"nimbal/usage/modules/#gait_gyro","title":"gait_gyro","text":""},{"location":"nimbal/usage/modules/#nonwear","title":"nonwear","text":""},{"location":"nimbal/usage/modules/#pipeline","title":"pipeline","text":""},{"location":"nimbal/usage/modules/#sleep","title":"sleep","text":""},{"location":"nimbal/usage/tutorials/step_detection/step_detect/","title":"Tutorial: Step detection","text":"<p>This example shows how to detect steps and phases of gait using a single Axivity worn on the right ankle.</p>"},{"location":"nimbal/usage/tutorials/step_detection/step_detect/#import-libraries","title":"Import libraries","text":"<p>Import the nimbalwear package, along with some plotting and computing libraries to help visualize the data:</p> <pre><code>import nimbalwear as nw\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import ndimage\n</code></pre>"},{"location":"nimbal/usage/tutorials/step_detection/step_detect/#loading-axivity-data","title":"Loading Axivity data","text":"<p>In this example, an Axivity sensor was placed on the right ankle. First, we need to instantiate a <code>Device</code> object, and then use the <code>import_axivity()</code> method to hold the raw .CWA data.</p> <pre><code>ax_device = nw.data.Device()\nax_device.import_axivity('right_ankle.cwa')\n</code></pre>"},{"location":"nimbal/usage/tutorials/step_detection/step_detect/#plot-raw-data","title":"Plot raw data","text":"<p>The data channels for the sensor can be listed using the <code>signal_headers</code> property</p> <pre><code>ax_device.signal_headers\n</code></pre> <pre><code>[{'label': 'Accelerometer x',\n  'transducer': 'MEMS',\n  'dimension': 'g',\n  'sample_rate': 100.0,\n  'physical_max': 3.16064453125,\n  'physical_min': -4.721923828125,\n  'digital_max': 32767,\n  'digital_min': -32768,\n  'prefilter': ''},\n {'label': 'Accelerometer y',\n  'transducer': 'MEMS',\n  'dimension': 'g',\n  'sample_rate': 100.0,\n  'physical_max': 3.7880859375,\n  'physical_min': -2.07373046875,\n  'digital_max': 32767,\n  'digital_min': -32768,\n  'prefilter': ''},\n {'label': 'Accelerometer z',\n  'transducer': 'MEMS',\n  'dimension': 'g',\n  'sample_rate': 100.0,\n  'physical_max': 4.8095703125,\n  'physical_min': -3.11279296875,\n  'digital_max': 32767,\n  'digital_min': -32768,\n  'prefilter': ''},\n  ...\n  ]\n</code></pre> <p>And the index for each signal can be found using the <code>get_signal_index()</code> method. In this case, we want to find the index of the vertical acceleration direction (y-axis) in order to detect steps:</p> <pre><code>ax_device.get_signal_index('Accelerometer y')\n</code></pre> <pre><code>1\n</code></pre> <p>The returned index is 1, referring to the second data stream (as expected from the signal header outputs above).</p> <p>We can now plot the corresponding raw data using the <code>signals</code> property and the signal index:</p> <pre><code>vert_acc_index = ax_device.get_signal_index('Accelerometer y')\nvert_acc_data = ax_device.signals[vert_acc_index]\n\nplt.plot(vert_acc_data)\nplt.show()\n</code></pre> <p></p>"}]}